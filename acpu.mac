	.title	GOBLI2
	.enabl	LC
	.list	MEB

C_MAX_RAM =: 120000

.macro	.ppu	X
	mov	X, PpuComm
	tst	PpuComm
	bne	.-4
.endm

	.asect
	.=1000

@include common.mac

Start:	call	RunPpu
	call	SetupLVaddr				; level addrs -> vaddr table
	clrb	bGameMode

; main cycle
Main:	movb	bGameMode, R0
	asl	R0
	call	@GameProcedures(R0)
	br	Main

GameProcedures:
	.word	MainInit, MainMenu, MainPreLev, MainLevel, MainOver, MainWin

ExitAll:
	mtps	#200
	call	MusicMute
	mov	#177777, PpuComm
	tst	PpuComm
	bmi	.-4
	call	FrePpu
	mov	#MsgSetScr, R0
Exit:	call	PriSt0
	mtps	#0
	emt	350
	halt

MsgNoPpu:	.asciz	"(!) PPU memory allocate failed"<12><15>
MsgSetScr:	.asciz	<14>
		.even

; ////////////////////////////////////////////////////////////////////////////

; prepare menu
MainInit:
	call	MenuMusicInit
	call	StopSound
	call	FadeScreen
	call	WaitVsync
	; reset screen scroll (if any)
	.ppu	#C_PPU_VBLACK
	.ppu	#C_PPU_VRST
	; title picture
	mov	#Menu1Data, R0
	mov	#50.*C_SCRWID*2, R1
	call	UnpR12
	; select level
	mov	#MsgSelLev, R0
	mov	#C_MENU_Y-008.*C_SCRWID+C_MENU_X-2+C_VADDR, R5
	call	PrintStr	
	call	MenuLevel
	; music
	mov	#MsgMenu001, R0
	mov	#C_MENU_Y+012.*C_SCRWID+C_MENU_X+C_VADDR, R5
	call	PrintStr
	call	MenuMusicOnOff
	tstb	bHaveAY
	bne	10$
	mov	#C_MENU_Y+012.*C_SCRWID+C_MENU_X+C_VADDR, R1
	mov	#22., R2
	call	DarkenVaddr
10$:	; instructions
	mov	#MsgMenu002, R0
	mov	#C_MENU_Y+024.*C_SCRWID+C_MENU_X+C_VADDR, R5
	call	PrintStr
	; quit
	mov	#MsgMenu000, R0
	mov	#C_MENU_Y+036.*C_SCRWID+C_MENU_X+C_VADDR, R5
	call	PrintStr
	; press space
	mov	#MsgPreSpace, R0
	mov	#C_MENU_Y+058.*C_SCRWID+C_MENU_X+3.+C_VADDR, R5
	call	PrintStr
	; set game variables
	mov	#5.*16., Lives
	clrb	bLevel
	call	MenuLevel
	; 
	clrb	bKeyCur
	movb	#C_MODE_MENU, bGameMode
	.ppu	#C_PPU_VNORM
	return


; menu
MainMenu:
	; wait for timer
	call	WaitVsync
	call	MusicPlay
	; 1 music
	cmpb	bKeyCur, #C_KEY_1
	bne	20$
	clrb	bKeyCur
	tstb	bHaveAY
	beq	20$
	call	MenuSound
	call	MusicMute
	comb	bUseMusic
	call	MenuMusicOnOff
	return
20$:	; 2 instructions
	cmpb	bKeyCur, #C_KEY_2
	bne	30$
	call	MusicMute
	call	ShowInstrA
	clrb	bGameMode
	return
30$:	; 0 exit
	cmpb	bKeyCur, #C_KEY_0
	bne	40$
	jmp	ExitAll
40$:	; Space
	cmpb	bKeyCur, #C_KEY_SPACE
	bne	50$
	movb	#C_MODE_PRELEV, bGameMode
	return
50$:	; <-
	cmpb	bKeyCur, #C_KEY_LEFT
	bne	60$
	clrb	bKeyCur
	call	MenuSound
	movb	bLevel, R0
	sub	#4., R0
	bpl	52$
	clr	R0
52$:	movb	R0, bLevel
	br	MenuLevel
60$:	; ->
	cmpb	bKeyCur, #C_KEY_RIGHT
	bne	70$
	clrb	bKeyCur
	call	MenuSound
	movb	bLevel, R0
	add	#4., R0
	cmp	R0, #C_MAX_LEVEL
	blt	62$
	mov	#C_MAX_LEVEL-4, R0
62$:	movb	R0, bLevel
	br	MenuLevel
70$:	; cheat - win screen (first select level I)
	cmpb	bKeyCur, #10				; K1
	bne	99$
	clrb	bKeyCur
	cmpb	bLevel, #8.
	bne	99$
	movb	#C_MODE_WIN, bGameMode
99$:	return


; show menu level char
MenuLevel:
	movb	bLevel, R0
	add	#'A, R0
	movb	R0, MsgSelLevA+1
	mov	#MsgSelLevA, R0
	mov	#C_MENU_Y-008.*C_SCRWID+C_MENU_X+26.+C_VADDR, R5
	call	PrintStr
	return


; init menu music
MenuMusicInit:
	mov	#3, R0					; music #
	clr	R1					; repeat
	call	MusicInit
	return

; show music on/off switch
MenuMusicOnOff:
	mov	#MsgOff, R0
	tstb	bUseMusic
	beq	10$
	mov	#MsgOn, R0
10$:	mov	#C_MENU_Y+012.*C_SCRWID+C_MENU_X+16.+C_VADDR, R5
	call	PrintStr
	br	MenuMusicInit


; level prepare
MainPreLev:
	movb	bLevel, R0
	; win maybe?
	cmp	R0, #C_MAX_LEVEL
	bne	10$
	movb	#C_MODE_WIN, bGameMode
	return
10$:	; not win, continue init level
	bic	#^B1111111111111110, R0			; R0 - music #
	clr	R1					; R1 - 0 - repeat
	call	MusicInit				; 
	call	ShowInstr
	call	FadeScreen
	call	LoadLevel
	call	RemovedInit
	call	DrawLevel
	call	DrawBadge
	call	ShadowPrep
	call	ObjectsPrepare
	clr	bFrame					; (!) also clears bFrame2
	clrb	bKeyCur					; (!) word command
	mov	#UpdTileTable, UpdTileAddr
	movb	#C_MODE_LEVEL, bGameMode
	return


; game procedures
MainLevel:
	call	WaitVSync				; wait for timer
	call	LevelProc				; level proc
	call	MusicPlay				; music
	call	SoundProc				; sound
	cmpb	bKeyCur, #C_KEY_STOP			; check stop
	bne	10$
	clrb	bGameMode
10$:	call	IncFrames
	return


; game over
MainOver:
	call	MusicMute
	call	FadeScreen
	mov	#LevOver, R0
	call	UnpackLevel
	call	DrawLevel
	; prepare animated ghosts
	; scan level for them
	clr	R4
	mov	#LevelC, R5
	mov	#C_FIELD_DX*C_FIELD_DY, R3
10$:	cmpb	LevelC(R4), #C_TILE_GHOST
	bne	20$
	mov	R4, R0
	asl	R0
	mov	Level2Vaddr(R0), (R5)+			; use LevelC as buffer for ghosts vaddrs
20$:	inc	R4
	sob	R3, 10$
	clr	(R5)					; put zero as end marker
	; 
30$:	call	WaitVSync
	call	IncFrames
	movb	bFrame2, R4
	asr	R4
	; draw ghosts tiles
	mov	#LevelC, R5				; LevelC used as ghosts vaddrs table
40$:	mov	(R5)+, R1				; R1 <- vaddr
	beq	50$					; end of them
	movb	GSprUpDown(R4), R0			; R0 <- ghost 'up/down' sprite #
	call	DrawSTile
	br	40$
50$:	; need to wait for some time before keypress checking 
	; to prevent accidental keypress after game over
	call	KeyWCheck
	bcs	30$
	clrb	bGameMode
	return


; you are a winner
MainWin:
	call	MusicMute
	call	FadeScreen
	mov	#LevWin, R0
	call	UnpackLevel
	mov	#2, R0					; music #
	mov	#1, R1					; do not repeat	
	call	MusicInit
	; prepare scroll
	mov	#C_FIELD_DY-2*C_FIELD_DX+LevelC+1, WinCurLaddr
	mov	#C_TILE_DY-1*<C_TILE_DX*2>, WinCurTilea
	mov	#100012, WinCurVaddr
	mov	#50., WinCurDelay
	clr	12$+2
	; prepare text/stars
	call	WinTxtInit
	call	WinStarInit
	;
10$:	; scroll proc
	call	WaitVSync
	; do we need to scroll
12$:	tst	#000000
	bne	30$
	; scroll one line
	.ppu	#C_PPU_VSCR
	; draw one line of level field
	call	DrawWinLine
	; advance vaddr
	sub	#C_SCRWID, WinCurVaddr
	cmp	WinCurVaddr, #100000
	bhis	20$
	mov	#287.*C_SCRWID+100012, WinCurVaddr
20$:	; advance tiles offset
	sub	#<C_TILE_DX*2>, WinCurTilea
	bpl	90$
	mov	#C_TILE_DY-1*<C_TILE_DX*2>, WinCurTilea
	; advance level addr
	dec	WinCurDelay
	bpl	90$
	sub	#C_FIELD_DX, WinCurLaddr
	cmp	WinCurLaddr, #LevelC
	bhis	90$
	; stop further scrolling
	dec	12$+2
	;
30$:	; text proc
	call	WinTxtProc
	call	WinStarProc
90$:	; music/key loop
	call	MusicPlay
	call	KeyWCheck
	bcs	10$
	clrb	bGameMode
	return


; draws one (pixel) line of level 
WinCurLaddr:	.word	0				; level addr to draw
WinCurTilea:	.word	0				; offset in tiles to draw
WinCurVaddr:	.word	0				; vaddr where to draw line
WinCurDelay:	.word	0				; delay for advancing level addr (will repeat last level line)
DrawWinLine:
	mov	#176640, R4
	mov	#176642, R5
	; clear bottom line
	mov	WinCurVaddr, (R4)
	sub	#C_SCRWID, (R4)
	cmp	(R4), #100000
	bhis	10$
	add	#288.*C_SCRWID, (R4)
10$:	mov	#C_TILE_DX*C_FIELD_ODX, R3
12$:	clr	(R5)
	inc	(R4)
	sob	R3, 12$
	; draw top line
	mov	WinCurVaddr, (R4)
	mov	WinCurLaddr, R1
	mov	#C_FIELD_ODX, R3
20$:	movb	(R1)+, R0
	asl	R0
	mov	TilesAddr(R0), R0
	add	WinCurTilea, R0
	mov	(R0)+, (R5)
	inc	(R4)
	mov	(R0)+, (R5)
	inc	(R4)
	mov	(R0)+, (R5)
	inc	(R4)
	sob	R3, 20$
	return

WinTxt:		.asciz	<0>"T"<0>"H"<0>"A"<0>"N"<0>"K"<0>"S"<0>" "<0>"F"<0>"O"<0>"R"<0>" "<0>"P"<0>"L"<0>"A"<0>"Y"<0>"I"<0>"N"<0>"G"
WinTxtCidx:	.blkb	18.
WinTxtClrs:	.byte	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,2	; x21
		.even
WinTxtInit:
	mov	#WinTxtCidx, R0
	mov	#18., R1
10$:	movb	R1, (R0)+
	sob	R1, 10$
	return
WinTxtProc:
	; sort of delay
	add	#100000, #000000
	bcc	99$
	; set color indexes
	mov	#WinTxtCidx, R0
	mov	#WinTxt, R2
	mov	#18., R1
10$:	movb	(R0), R3
	asr	R3
	cmpb	R3, #20.
	blos	12$
	movb	#20., R3
12$:	movb	WinTxtClrs(R3), (R2)+
	inc	R2
	incb	(R0)
	bicb	#^B10000000, (R0)
	inc	R0
	sob	R1, 10$
	; print
	mov	WinCurVaddr, R5
	add	#C_SCRWID*14.+10., R5
	mov	#WinTxt, R0
	call	PrintStr
99$:	return


WinStarTile:	.byte	42., 43., 44., 43., 42., 0
WinStarBuf:	.word	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
WinStarInit:
	mov	#WinStarBuf, R5
	clr	R4
	mov	#6, R3
10$:	call	WinStarRand				; R0 - 1..255
	mov	R0, (R5)+				; XYaddr
	mov	R4, (R5)+				; Tile idx
	inc	R4
	sob	R3, 10$
	return 
WinStarRand:
	call	Random8bit
	mov	R0, R1
	bic	#^B1111111111110000, R1			; R4 - X
	cmp	R1, #4.
	blos	10$
	cmp	R1, #15.-5.
	bhis	10$
	br	WinStarRand
10$:	mov	R0, R1
	ash	#-4, R1
	cmp	R1, #1.
	blos	WinStarRand
	return
WinStarProc:
	add	#20000, #100000
	bcc	99$
	mov	#WinStarBuf, R4
	mov	#6, R3
10$:	mov	(R4), R5
	bic	#^B1111111111110000, R5
	mul	#5., R5
	inc	R5
	mov	(R4)+, R1
	bic	#^B1111111100001111, R1
	ash	#-4, R1
	mul	#18.*C_SCRWID, R1
	add	R1, R5
	add	WinCurVaddr, R5
	sub	#10., R5
	mov	(R4), R0
	movb	WinStarTile(R0), R0
	mov	R4, -(SP)
	mov	R3, -(SP)
	call	DrawTile
	mov	(SP)+, R3
	mov	(SP)+, R4
	; increase idx
	inc	(R4)
	cmp	(R4), #6
	bne	20$
	clr	(R4)
	call	WinStarRand
	mov	R0, -2(R4)
20$:	tst	(R4)+
	sob	R3, 10$
99$:	return


; check keypress after wait some, C=0 - pressed
KeyWCheck:
	tst	#100.
	beq	10$
	dec	KeyWCheck+2
	bne	30$
	clrb	bKeyCur
10$:	tstb	bKeyCur
	beq	30$
	mov	#100., KeyWCheck+2
	tst	(PC)+
30$:	sec
	return


; //////////////////////////////////////////////////////////////////////////////
; // Logic
; //////////////////////////////////////////////////////////////////////////////

; prepare vaddrs etc of objects
ObjectsPrepare:
	mov	#Object, R0
	call	ObjPrepare
	mov	#ObjectEnd, R0
	call	ObjPrepare
	mov	#ObjectEnd+ObjectEnd-Object, R0
	call	ObjPrepare
	return


; restore background under objects
ObjectsRestore:
	mov	#ObjectEnd+ObjectEnd-Object, R0
	call	ObjRestore
	mov	#ObjectEnd, R0
	call	ObjRestore
	mov	#Object, R0
	call	ObjRestore
	return


; save background and draw current sprites
ObjectsSprite:
	mov	#Object, R0
	call	ObjSprite
	mov	#ObjectEnd, R0
	call	ObjSprite
	mov	#ObjectEnd+ObjectEnd-Object, R0
	call	ObjSprite
	return


; level procedures 
LevelProc:
	; even frame - drawing
	bitb	#1, bFrame
	bne	100$
	call	ObjectsRestore				; restore background (reversed)
	; frame #4 - check tiles to update
	cmpb	bFrame, #4
	bne	20$
10$:	cmp	UpdTileAddr, #UpdTileTable
	beq	20$
	sub	#2, UpdTileAddr
	mov	@UpdTileAddr, R5
	movb	(R5), R0
	sub	#LevelC, R5
	asl	R5
	mov	Level2Vaddr(R5), R5
	call	DrawTile
	br	10$
20$:	call	ObjectsSprite				; draw sprites
	return
100$:	; odd frames
	cmpb	bFrame, #1
	bne	110$
	call	PStatePrepare				; prepare player state
	call	GStatePrepare				; prepare ghost states
110$:	call	PStateProcess				; process player states
	call	PStateWaitOut				; process player states wait and out
	call	GStateProcess				; process ghost states
	call	GStateWaitOut				; process ghost states wait and out
	call	ObjectsPrepare				; prepare sprites coords
	call	CheckTurn				; check if we can fast turn around
	call	CheckSpace				; check pressed space above removable block
	call	RemovedProcess				; process removed stone blocks
	call	CheckCollide				; check colliding with ghosts
	call 	SoundSet5				; set sound to play on frame 5
	call	ShadowSet				; set shadow to draw 
	call	DrawLives				; draw animated lives number
	return


; cycle frame numbers
IncFrames:
	incb	bFrame
	cmpb	bFrame, #12.
	blo	10$
	clrb	bFrame
10$:	incb	bFrame2
	cmpb	bFrame2, #24.
	blo	20$
	clrb	bFrame2
20$:	return


; set up conversion table level addr -> vaddr
SetupLVaddr:
	mov	#Level2Vaddr, R0
	mov	#8.-C_TILE_DY*C_SCRWID+2-C_TILE_DX+C_VADDR+C_VDIFF, R4	; start at (2,8.) without bounding box
	mov	#C_FIELD_DY, R2
10$:	mov	#C_FIELD_DX, R1
	mov	R4, R5
	add	#C_TILE_DY*C_SCRWID, R4
20$:	mov	R5, (R0)+
	add	#C_TILE_DX, R5
	sob	R1, 20$
	sob	R2, 10$
	return


; unpacks level data to LevelC, set empty borders (for instructions level)
; R0 - packed level data addr
UnpackLevel:
	mov	#LevelC, R1
	call	Unpack
	; adjust unpacked
	mov	#C_FIELD_ODX*C_FIELD_ODY+LevelC, R0	; end+1 of unpacked source
	mov	#C_FIELD_DX*C_FIELD_DY+LevelC-C_FIELD_DX, R1	; end+2 for unpacked dest
	mov	#C_FIELD_ODY, R3
10$:	mov	#C_FIELD_ODX, R2
	clrb	-(R1)
	movb	-(R0), -(R1)
	sob	R2, .-2
	clrb	-(R1)
	sob	R3, 10$
	; clear top/bottom borders
	mov	#LevelC, R0
	mov	#C_FIELD_DX, R3
20$:	clrb	C_FIELD_DY-1*C_FIELD_DX(R0)
	clrb	(R0)+
	sob	R3, 20$
	return


; load and prepare level
LoadLevel:
	; clear objects
	mov	#Object, R0
	mov	#ObjectsEnd-Object/2, R3
	clr	(R0)+
	sob	R3, .-2
	; unpack level
	movb	bLevel, R0
	asl	R0
	mov	LevelTable(R0), R0
	call	UnpackLevel
	; top/bottom borders
	mov	#LevelC, R0
	mov	#C_FIELD_DX, R3
20$:	movb	#C_TILE_BDOWN, C_FIELD_DY-1*C_FIELD_DX(R0)
	movb	#C_TILE_BUP, (R0)+
	sob	R3, 20$
	; left/right borders
	mov	#LevelC+C_FIELD_DX, R0
	mov	#C_FIELD_DY-2, R3
30$:	movb	#C_TILE_BRIGHT, C_FIELD_DX-1(R0)
	movb	#C_TILE_BLEFT, (R0)
	add	#C_FIELD_DX, R0
	sob	R3, 30$
	; corners
	movb	#C_TILE_BUPLE, LevelC
	movb	#C_TILE_BUPRI, C_FIELD_DX-1+LevelC
	movb	#C_TILE_BDOLE, C_FIELD_DY-1*C_FIELD_DX+LevelC
	movb	#C_TILE_BDORI, C_FIELD_DY*C_FIELD_DX-1+LevelC
	; locate player, gold, ghosts
	clrb	bGoldLeft
	clrb	bNextLevel
	mov	#LevelC, R0
	mov	#ObjectEnd, R2
	mov	#8.-C_TILE_DY, R5			; R5 - Y
40$:	mov	#2.-C_TILE_DX, R4			; R4 - X
50$:	cmpb	(R0), #C_TILE_BOX			; a box
	bne	52$
	incb	bGoldLeft
52$:	cmpb	(R0), #C_TILE_DOOR			; a door
	bne	54$
	mov	R0, DoorAddr				; save door addr
54$:	cmpb	(R0), #C_TILE_PLAYER			; 17. - player
	bne	60$
	mov	#Object, R1				; R1 <- obj addr
	call	200$
	clrb	(R0)					; remove object from level map
60$:	cmpb	(R0), #C_TILE_GHOST			; 16. - ghost (not removing from map)
	bne	70$
	mov	R2, R1					; R1 <- obj addr
	call	200$
	add	#ObjectEnd-Object, R2			; advance ghost # (only 2 ghosts allowed!)
	clrb	(R0)
70$:	inc	R0
	add	#C_TILE_DX, R4				; next X
	cmp	R4, #C_FIELD_DX*C_TILE_DX+2.-C_TILE_DX
	blo	50$
	add	#C_TILE_DY, R5				; next Y
	cmp	R5, #C_FIELD_DY*C_TILE_DY+8.-C_TILE_DY
	blo	40$
	; init player/ghosts
	call	ObjectsReinit
	return
200$:	; setup player or ghost initial coords
	mov	R4, C_OBJ_INITX(R1)
	mov	R5, C_OBJ_INITY(R1)
	mov	R0, C_OBJ_INITLA(R1)
	return


; reinitialization of objects, copy init coords to working 
ObjectsReinit:
	mov	#Object, R1
10$:	call	ObjectInit
	add	#ObjectEnd-Object, R1
	cmp	R1, #ObjectsEnd
	blo	10$
	return
ObjectInit:	
	mov	C_OBJ_INITX(R1), C_OBJ_X(R1)
	mov	C_OBJ_INITY(R1), C_OBJ_Y(R1)
	mov	C_OBJ_INITLA(R1), C_OBJ_LEVADDR(R1)
	mov	#C_STATE_WAIT, C_OBJ_STATE(R1)
	mov	#C_SPR_PSPAWN1, C_OBJ_SPRITE(R1)
	cmp	R1, #Object
	beq	20$
	mov	#C_SPR_GSPAWN1, C_OBJ_SPRITE(R1)
20$:	mov	R1, R2
	add	#C_OBJ_SAVED, R2
	mov	#C_OBJ_LEVADDR-C_OBJ_SAVED/2, R3
	clr	(R2)+
	sob	R3, .-2
	return


; can go left if have movable on the left
; do NOT modify anything except R5
; returns: C=1 - we can't
ChkSLeft:	movb	-1(R1), R5			; take left side tile
		bitb	#C_BIT_MOVE, TTileBits(R5)	; check for movable
		beq	ChkSSetC			; unable to move
		mov	#-1, R5
ChkSClrC:	; now R5 - dvaddr for 'move to', ghosts can's move on ghost - check it
		cmp	R0, #Object
		beq	10$
		add	R1, R5				; R5 - levaddr of 'move to' position
		cmp	R5, ObjectEnd+C_OBJ_LEVADDR
		beq	ChkSSetC
		cmp	R5, ObjectEnd+ObjectEnd-Object+C_OBJ_LEVADDR
		beq	ChkSSetC
10$:		tst	(PC)+
ChkSSetC:	sec
		return

; check going right
ChkSRight:	movb	1(R1), R5
		bitb	#C_BIT_MOVE, TTileBits(R5)
		beq	ChkSSetC
		mov	#1, R5
		br	ChkSClrC

; can climb up if: 1-have moveable above, 2-we are on ladder
ChkSUp:		movb	-C_FIELD_DX(R1), R5
		bitb	#C_BIT_MOVE, TTileBits(R5)
		beq	ChkSSetC
		cmpb	(R1), #C_TILE_LADDER
		bne	ChkSSetC
		mov	#-C_FIELD_DX, R5
		br	ChkSClrC

; check climbing down: have ladder below OR (on ladder and movable below)
ChkSDown:	movb	C_FIELD_DX(R1), R5
		cmpb	R5, #C_TILE_LADDER
		bne	10$
		mov	#C_FIELD_DX, R5
		br	ChkSClrC
10$:		bitb	#C_BIT_MOVE, TTileBits(R5)
		beq	ChkSSetC		
		cmpb	(R1), #C_TILE_LADDER
		bne	ChkSSetC
		mov	#C_FIELD_DX, R5
		br	ChkSClrC

; check if can fall: 1-we aren't on ladder, 2-fallable below, 3-aren't waiting keypress
ChkSFall:	cmpb	(R1), #C_TILE_LADDER
		beq	ChkSSetC
		movb	C_FIELD_DX(R1), R5
		bitb	#C_BIT_FALL, TTileBits(R5)
		beq	ChkSSetC
		cmp	R2, #C_STATE_WAIT
		beq	ChkSSetC
		mov	#C_FIELD_DX, R5
		br	ChkSClrC

; check if can stop - always can (even in mid-fall)
ChkSStop:	clc
		return


; prepare player state
PStatePrepare:
	mov	#Object, R0
	mov	C_OBJ_LEVADDR(R0), R1
	mov	C_OBJ_STATE(R0), R2
	; do nothing at out state
	cmp	R2, #C_STATE_OUT
	beq	09$
	; awaiting keypress?
	cmp	R2, #C_STATE_WAIT
	bne	20$
	tstb	bKeyCur
	bne	10$
09$:	return
10$:	mov	#C_STATE_STOP, R2
	mov	R2, C_OBJ_STATE(R0)			; set state immediately, to be sure
	mov	#C_SPR_PLEFT1, C_OBJ_SPRITE(R0)		; and set sprite
20$:	; check if at exit
	cmpb	(R1), #C_TILE_EXIT
	bne	22$
	incb	bNextLevel
	mov	#C_STATE_OUT, C_OBJ_STATE(R0)
	return
22$:	; check if can fall (and nothing else maaatttteeers (c))
	call	ChkSFall
	bcc	30$
	; chain below - special, fall if 1) key down 2) already falling AND no key up/enter
	cmpb	C_FIELD_DX(R1), #C_TILE_CHAIN
	bne	40$
	cmpb	bKeyCur, #C_KEY_DOWN
	beq	30$
	cmp	R2, #C_STATE_FALL
	bne	40$
	cmpb	bKeyCur, #C_KEY_UP
	beq	40$
	cmpb	bKeyCur, #C_KEY_ENTER
	beq	40$
30$:	; check for a ghost below (can't fall on ghost)
	mov	R1, R5
	add	#C_FIELD_DX, R5
	cmp	R5, ObjectEnd+C_OBJ_LEVADDR
	beq	40$
	cmp	R5, ObjectEnd+ObjectEnd-Object+C_OBJ_LEVADDR
	beq	40$
	; falling immediately
	mov	#C_STATE_FALL, C_OBJ_STATE(R0)
	add	#C_FIELD_DX, C_OBJ_LEVADDR(R0)
	mov	C_OBJ_LEVADDR(R0), R5			; don't forget to check eating box
	br	290$
40$:	; check keys
	movb	bKeyCur, R3
	mov	#KeysActions, R4
50$:	cmp	R3, (R4)				; is it our key?
	bne	60$
	call	@TStateAvail-KeysActions(R4)		; check for direction avail
	bcs	100$
	sub	#KeysActions, R4
	asr	R4
	mov	R4, R2					; proposed state change
	br	100$
60$:	tst	(R4)+
	cmp	R4, #TStateAvail
	blo	50$
100$:	; proposed or previous state must be in R2 now, check it
	mov	R2, R5
	asl	R5
	call	@TStateAvail(R5)
	bcc	200$
	; if stop from climbing down - change sprite
	cmp	R2, #C_STATE_DOWN
	bne	110$
	mov	#C_SPR_PLEFT1, C_OBJ_SPRITE(R0)
	br	190$
110$:	; if stop from climbing up AND not on ladder - change sprite
	cmp	R2, #C_STATE_UP
	bne	190$
	cmpb	(R1), #C_TILE_LADDER
	beq	190$
	mov	#C_SPR_PLEFT1, C_OBJ_SPRITE(R0)
190$:	mov	#C_STATE_STOP, R2
	clrb	bKeyCur					; also clears key after stop	
200$:	; adjust level addr and state
	movb	DStateLevaddr(R2), R5			; direction delta
	add	R1, R5					; add current level addr
	mov	R5, C_OBJ_LEVADDR(R0)
	mov	R2, C_OBJ_STATE(R0)
290$:	; check for eating box
	cmpb	(R5), #C_TILE_BOX
	bne	299$
	clrb	(R5)
	mov	R5, @UpdTileAddr
	add	#2, UpdTileAddr
	movb	#C_SND_BOX, bSoundFr5
	; maybe open the door to exit
	decb	bGoldLeft
	bne	299$
	movb	#C_TILE_EXIT, @DoorAddr
	mov	DoorAddr, @UpdTileAddr
	add	#2, UpdTileAddr
	movb	#C_SND_EXOPEN, bSoundFr5	
299$:	return


; process out for player (live lost)
PStateWaitOut:
	cmpb	bFrame, #11.
	bne	99$
	cmp	Object+C_OBJ_STATE, #C_STATE_OUT
	bne	99$
	; are we exiting?
	tstb	bNextLevel
	beq	10$
	incb	bLevel
	movb	#C_MODE_PRELEV, bGameMode
	; add 1 live if they are <9.
	cmp	Lives, #8.*16.
	bhi	09$
	add	#16., Lives
09$:	return
10$:	sub	#16., Lives
	bpl	20$
	movb	#C_MODE_OVER, bGameMode
	return
20$:	; player to respawn point
	mov	#Object, R0
	mov	C_OBJ_INITX(R0), C_OBJ_X(R0)
	mov	C_OBJ_INITY(R0), C_OBJ_Y(R0)
	mov	C_OBJ_INITLA(R0), C_OBJ_LEVADDR(R0)
	mov	#C_STATE_WAIT, C_OBJ_STATE(R0)
	mov	#C_SPR_PSPAWN1, C_OBJ_SPRITE(R0)
90$:	clrb	bKeyCur
99$:	return


; prepare ghost state
GStatePrepare:
	mov	#ObjectEnd, R0
	call	10$
	add	#ObjectEnd-Object, R0
10$:	tst	C_OBJ_X(R0)				; is object present
	beq	99$
	mov	C_OBJ_LEVADDR(R0), R1
	mov	C_OBJ_STATE(R0), R2
	; check for sitting in a trap
	cmpb	(R1), #C_TILE_REMO
	bne	20$
	cmp	R2, #C_STATE_OUT
	beq	99$
	mov	#C_STATE_STOP, C_OBJ_STATE(R0)
	return
20$:	; do nothing at wait or out states
	cmp	R2, #C_STATE_WAIT
	blo	100$
99$:	return
100$:	; first of all - check for a fall
	call	ChkSFall
	bcs	120$
110$:	mov	#C_STATE_FALL, C_OBJ_STATE(R0)
	add	#C_FIELD_DX, C_OBJ_LEVADDR(R0)
	return
120$:	; fall through chain
	cmp	R2, #C_STATE_FALL
	bne	300$
	cmpb	C_FIELD_DX(R1), #C_TILE_CHAIN
	beq	110$
300$:	; try to move somewhere in direction of player
	; put diff in coords
	mov	Object+C_OBJ_X, R3
	sub	C_OBJ_X(R0), R3
	; asl	R3
	; asl	R3					; make Y diff more preferable
	mov	R3, C_STATE_RIGHT*2+GhostDiff
	neg	R3
	mov	R3, C_STATE_LEFT*2+GhostDiff
	mov	Object+C_OBJ_Y, R3
	sub	C_OBJ_Y(R0), R3
	mov	R3, C_STATE_DOWN*2+GhostDiff
	neg	R3
	mov	R3, C_STATE_UP*2+GhostDiff
	; put penalty for trying to move in opposite to current dir
	movb	TStateOppo(R2), R5
	asl	R5
	sub	#400, GhostDiff(R5)
	; select biggest diff then (with checks for avail)
	mov	#-10000, R3
	mov	#C_STATE_DOWN*2, R4
	mov	#C_STATE_STOP, R2
310$:	; check move avail
	call	@TStateAvail(R4)
	bcs	320$
	; select bigger diff
	cmp	GhostDiff(R4), R3
	blt	320$
	mov	R4, R2
	asr	R2
	mov	GhostDiff(R4), R3
320$:	sub	#2, R4
	bne	310$
	; proposed or previous state must be in R2 now, check it again (just in case)
	mov	R2, R5
	asl	R5
	call	@TStateAvail(R5)
	bcc	400$
	mov	#C_STATE_STOP, R2	
400$:	; adjust level addr and state
	movb	DStateLevaddr(R2), R5			; direction delta
	add	R1, R5					; add current level addr
	mov	R5, C_OBJ_LEVADDR(R0)
	mov	R2, C_OBJ_STATE(R0)
499$:	return


; prepare in wait or out states at frame #11
GStateWaitOut:
	cmpb	bFrame, #11.
	bne	99$
	mov	#ObjectEnd, R0
	call	10$
	add	#ObjectEnd-Object, R0
10$:	mov	C_OBJ_STATE(R0), R2			; also ok with no object
	beq	99$
	; wait -> stop
	cmp	R2, #C_STATE_WAIT
	bne	20$
	mov	#C_STATE_STOP, R2
	br	90$
20$:	; out -> respawn (wait)
	cmp	R2, #C_STATE_OUT
	bne	99$
	mov	#C_STATE_WAIT, R2
	mov	C_OBJ_INITX(R0), C_OBJ_X(R0)
	mov	C_OBJ_INITY(R0), C_OBJ_Y(R0)
	mov	C_OBJ_INITLA(R0), C_OBJ_LEVADDR(R0)
	clr	C_OBJ_SAVED(R0)
90$:	mov	R2, C_OBJ_STATE(R0)
99$:	return


; process player states
PStateProcess:
	movb	bFrame, R4
	asr	R4
	movb	bFrame2, R5
	asr	R5
	mov	#Object, R0
	mov	C_OBJ_STATE(R0), R1
	asl	R1
	add	R1, PC
	return						; 00 stop
	br	PStateLeft				; 01 left
	br	PStateRight				; 02 right
	br	PStateUp				; 03 up
	br	PStateDown				; 04 down
	br	PStateFall				; 05 fall
	br	PStateWait				; 06 wait
	br	PStateOut				; 07 out

PStateLeft:	movb	DxLeft(R4), R1			; where is ADDB?!
		add	R1, C_OBJ_X(R0)			; increase X
		movb	SprLeft(R5), C_OBJ_SPRITE(R0)	; roll sprite
		return
PStateRight:	movb	DXRight(R4), R1
		add	R1, C_OBJ_X(R0)
		movb	SprRight(R5), C_OBJ_SPRITE(R0)
		return
PStateUp:	movb	DYUp(R4), R1
PStateUpC:	add	R1, C_OBJ_Y(R0)	
		movb	SprUpDown(R5), C_OBJ_SPRITE(R0)
		return
PStateDown:	movb	DYDown(R4), R1
		br	PStateUpC
PStateFall:	add	#2, C_OBJ_Y(R0)
		return
PStateWait:	cmpb	C_OBJ_SPRITE(R0), SprSpawn+5
		beq	99$
		movb	SprSpawn(R4), C_OBJ_SPRITE(R0)	; (!) used bFrame/2
99$:		return
PStateOut:	movb	SprOut(R4), C_OBJ_SPRITE(R0)	; (!) used bFrame/2
		return


; process ghost states
GStateProcess:
	; (!) R4, R5 must be already set to bFrame/2 and bFrame2/2
	mov	#ObjectEnd, R0
	call	10$
	add	#ObjectEnd-Object, R0
10$:	tst	C_OBJ_X(R0)				; no object?
	beq	99$
	mov	C_OBJ_STATE(R0), R1
	asl	R1
	add	R1, PC
	br	GStateStop				; 00 stop - animate
	br	GStateLeft				; 01 left
	br	GStateRight				; 02 right
	br	GStateUp				; 03 up
	br	GStateDown				; 04 down
	br	PStateFall				; 05 fall - use player's fall
	br	GStateWait				; 06 wait - animate
	br	GStateOut				; 07 out
99$:	return

GStateStop:	movb	GSprUpDown(R5), C_OBJ_SPRITE(R0)
		return
GStateLeft:	movb	GDxLeft(R4), R1
		add	R1, C_OBJ_X(R0)
		movb	GSprRight(R5), C_OBJ_SPRITE(R0)
		return
GStateRight:	movb	DXRight(R4), R1
		add	R1, C_OBJ_X(R0)
		movb	GSprRight(R5), C_OBJ_SPRITE(R0)
		return
GStateUp:	sub	#2, C_OBJ_Y(R0)	
		movb	GSprUpDown(R5), C_OBJ_SPRITE(R0)
		return
GStateDown:	add	#2, C_OBJ_Y(R0)	
		movb	GSprUpDown(R5), C_OBJ_SPRITE(R0)
		return
GStateWait:	movb	GSprWait(R4), C_OBJ_SPRITE(R0)	; (!) use bFrame/2
		return
GStateOut:	movb	GSprOut(R4), C_OBJ_SPRITE(R0)	; (!) use bFrame/2
		return


; check for turnaround on frame #5
CheckTurn:
	cmpb	bFrame, #5
	bne	99$
	; run checks
	mov	Object+C_OBJ_STATE, R2
	mov	#TTurnTable, R5
	mov	#4, R3
10$:	movb	(R5)+, R1
	movb	(R5)+, R4
	cmpb	R2, (R5)+
	bne	20$
	cmpb	bKeyCur, (R5)
	bne	20$
	movb	1(R5), R2
	br	90$
20$:	inc	R5
	inc	R5
	sob	R3, 10$
	return
90$:	; apply new state, need to update level addr (!)
	mov	R2, Object+C_OBJ_STATE
	add	R4, Object+C_OBJ_LEVADDR
	add	R1, Object+C_OBJ_X	
99$:	return

TTurnTable:	
	; x adj, levaddr adj, state now, key, new state
	.byte	+1, -1, C_STATE_RIGHT, C_KEY_LEFT, C_STATE_LEFT
	.byte	-1, +1, C_STATE_LEFT, C_KEY_RIGHT, C_STATE_RIGHT
	.byte	0, -C_FIELD_DX, C_STATE_DOWN, C_KEY_UP, C_STATE_UP
	.byte	0, +C_FIELD_DX, C_STATE_UP, C_KEY_DOWN, C_STATE_DOWN


; check space keypress and destroy small stone blocks if needed
CheckSpace:
	cmpb	bKeyCur, #C_KEY_SPACE			; no space pressed?
	bne	99$
	mov	Object+C_OBJ_LEVADDR, R1
	mov	Object+C_OBJ_STATE, R2
	movb	DStateLevaddr(R2), R5
	sub	R5, R1					; 'rewind' level addr to previous
	add	#C_FIELD_DX, R1				; take block 'below'
	movb	(R1), R5
	bitb	#C_BIT_DEST, TTileBits(R5)
	beq	99$
	; check for empty slot in 'removed' table
	mov	#Removed, R0
	mov	#RemovedEnd-Removed/6, R3
10$:	tst	(R0)					; timer < 0 - free space
	bmi	90$
	add	#6, R0
	sob	R3, 10$
	return
90$:	; add to 'removed'
	mov	#C_REMO_TIME, (R0)+			; put timer
	mov	R1, (R0)+				; put level addr
	movb	(R1), R3
	mov	R3, (R0)+				; put tile #
	; remove tile
	movb	#C_TILE_REMO, R0
	movb	R0, (R1)
	sub	#LevelC, R1
	asl	R1
	mov	Level2Vaddr(R1), R5
	call	DrawTile
	clrb	bKeyCur
	movb	#C_SND_REMO, bSoundNum
99$:	return


; init 'removed' table with -1
RemovedInit:
	mov	#Removed, R0
	mov	#RemovedEnd-Removed/2, R3
10$:	mov	#-1, (R0)+
	sob	R3, 10$
	return


; process removed tiles table
RemovedProcess:
	cmpb	bFrame, #11.				; work on last frame
	bne	199$
	mov	#Removed, R4
10$:	tst	(R4)					; test timer
	bmi	190$					; nothing here, continue
	beq	20$					; already at zero, try to restore again
	dec	(R4)					; decrease timer
	bne	190$					; still have time
20$:	; (R4) - timer, 2(R4) - level addr, 4(R4) - tile #
	; do not restore if any object is moving in or moving out
	mov	#Object, R0
30$:	mov	C_OBJ_LEVADDR(R0), R1			; current levaddr
	mov	C_OBJ_STATE(R0), R2
	cmp	R1, 2(R4)				; moving in?
	beq	100$
	movb	DStateLevaddr(R2), R5
	sub	R5, R1					; previous levaddr
	cmp	R1, 2(R4)				; moved out?
	beq	100$
	add	#ObjectEnd-Object, R0
	cmp	R0, #ObjectsEnd
	blo	30$
	; set tile to restore then
	mov	2(R4), R5
	movb	4(R4), (R5)				; restore tile in map
	mov	R5, @UpdTileAddr			; put addr to table to draw tiles
	add	#2, UpdTileAddr
	dec	(R4)					; set timer to -1, empty saved
	br	190$
100$:	; if object is at stop - set to 'out' (kill it)
	cmp	R2, #C_STATE_STOP
	bne	190$
	mov	#C_STATE_OUT, C_OBJ_STATE(R0)
190$:	; continue cycle removed
	add	#6, R4
	cmp	R4, #RemovedEnd
	blo	10$
199$:	return


; check ghosts colliding with player
; C=0 collided
CheckCollide:
	mov	#Object, R0
	cmp	C_OBJ_STATE(R0), #C_STATE_OUT		; not testing already out
	beq	90$
	mov	C_OBJ_X(R0), R1
	mov	C_OBJ_Y(R0), R2
	mov	#ObjectEnd, R5
	call	50$
	add	#ObjectEnd-Object, R5
50$:	mov	C_OBJ_X(R5), R4				; no object?
	beq	90$
	sub	R1, R4					; move to player coordinates
	cmp	R4, #C_TILE_DX
	bge	90$
	cmp	R4, #-C_TILE_DX
	ble	90$
	mov	C_OBJ_Y(R5), R4
	sub	R2, R4
	cmp	R4, #C_TILE_DY
	bge	90$
	cmp	R4, #-C_TILE_DY
	ble	90$
	; collided, player is out
	mov	#C_STATE_OUT, C_OBJ_STATE(R0)
	movb	#C_SND_LOST, bSoundFr5
90$:	return


; set shadow tile to draw (if conditions are met)
ShadowSet:
	cmpb	bFrame, #1				; only on frame #1
	bne	99$
	tstb	bGoldLeft				; only without boxes
	bne	99$
	; first - modify previous shadows if any
	mov	#ShadowTable, R0
	call	ShadowRem
	call	ShadowRem
	; try to add shadow
	mov	#Object, R0
	mov	C_OBJ_LEVADDR(R0), R1
	mov	C_OBJ_STATE(R0), R2			; R2 - state
	movb	DStateLevaddr(R2), R5
	sub	R5, R1					; R1 - previous level addr
	tstb	(R1)					; must be nothing at it
	bne	99$
	movb	TShadowTiles(R2), R5			; R5 - shadow tile for this state
	beq	99$
	movb	R5, (R1)
	mov	R1, @UpdTileAddr			; put to update tile table
	add	#2, UpdTileAddr
	; update shadow addr in table
	mov	#ShadowTable, R0
	tst	(R0)+
	beq	90$
	tst	(R0)+
	bne	99$
90$:	mov	R1, -(R0)
99$:	return

; fade and remove
ShadowRem:
	mov	(R0)+, R1				; R1 - level addr of shadow
	beq	99$
	movb	(R1), R2				; R2 - shadow tile
	; dumb compare and modify
	cmp	R2, #C_TILE_SHALEF
	beq	10$
	cmp	R2, #C_TILE_SHARIG
	beq	10$
	dec	R2
	br	20$
10$:	clr	R2
20$:	mov	R1, @UpdTileAddr
	add	#2, UpdTileAddr
	movb	R2, (R1)
	bne	99$
	clr	-2(R0)
99$:	return

; prepare (just clear) shadow table
ShadowPrep:
	mov	#ShadowTable, R0
	clr	(R0)+
	clr	(R0)+
	return

ShadowTable:	.word	0, 0


; //////////////////////////////////////////////////////////////////////////////
; // Music
; //////////////////////////////////////////////////////////////////////////////

; check if we need to do anything 
; and return to previous call if not
MusicChk:
	tstb	bHaveAY
	beq	90$
	tstb	bUseMusic
	beq	90$
	return
90$:	tst	(SP)+					; skip one call
	return

; R0 - music # (0..2), R1 - 0-repeat, <>0-no repeat
MusicInit:
	call	MusicChk
	jmp	Pt3Init

; call this every frame after init
MusicPlay:
	call	MusicChk
	jmp	Pt3Play

; set all AY regs to zero 
MusicMute:
	call	MusicChk
	jmp	Pt3Mute


; //////////////////////////////////////////////////////////////////////////////
; // Drawing
; //////////////////////////////////////////////////////////////////////////////

; fade screen by randomly removing tiles
FadeScreen:
	mov	#176640, R4
	mov	#176642, R5
	mov	#255., R3
10$:	call	Random8bit				; R0 = (byte) [X][Y]
	call	50$
	sob	R3, 10$
	clr	R0					; because we haven't 0 in random
50$:	; clear one tile 5x16 
	; R0 - 0..255 -> vaddr
	mov	#100000, (R4)
	mov	R0, R1
	bic	#^B1111111111110000, R1			; X 0..15
	mul	#5, R1					; to tile X
	add	R1, (R4)
	mov	R0, R1
	bic	#^B1111111100001111, R1			; Y 0..15
	ash	#-4, R1	
	mul	#C_SCRWID*18., R1			; to tile Y
	add	R1, (R4)
	; clear tile
	mov	#18., R2
	mov	#C_SCRWID-4, R1
60$:	clr	(R5)
	inc	(R4)
	clr	(R5)
	inc	(R4)
	clr	(R5)
	inc	(R4)
	clr	(R5)
	inc	(R4)
	clr	(R5)
	add	R1, (R4)
	sob	R2, 60$
	return


; R0 - tile #, R5 - vaddr
DrawTile:
	mov	#176640, R4
	mov	R5, (R4)
	mov	#176642, R5
	asl	R0
	mov	TilesAddr(R0), R0
	mov	#C_SCRWID-2, R1
	mov	#C_TILE_DY, R2
10$:	mov	(R0)+, (R5)
	inc	(R4)
	mov	(R0)+, (R5)
	inc	(R4)
	mov	(R0)+, (R5)
	add	R1, (R4)
	sob	R2, 10$
	return


; prepare object values (vaddr, spr addr etc.)
; R0 - object addr
ObjPrepare:	
	; set vaddr
	mov	(R0)+, R2				; X (0..63)
	beq	99$					; no object?
	mov	(R0)+, R1				; Y (0..255)
	mul	#C_SCRWID, R1
	add	R2, R1
	add	#C_VADDR+C_VDIFF, R1
	mov	R1, (R0)+				; vaddr
	; set sprite addr
	mov	(R0)+, R1
	asl	R1
	mov	SpritesAddr(R1), R1
	mov	R1, (R0)+				; saddr
99$:	return


; restore object's background
; R0 - object addr
ObjRestore:
	mov	#176640, R4
	mov	#176642, R5
	add	#C_OBJ_SAVED, R0
	mov	(R0)+, (R4)				; R1 - saved vaddr
	beq	99$					; not saved yet?
	mov	#C_SCRWID-2, R2
	mov	#C_TILE_DY, R3
10$:	mov	(R0)+, (R5)
	inc	(R4)
	mov	(R0)+, (R5)
	inc	(R4)
	mov	(R0)+, (R5)
	add	R2, (R4)
	sob	R3, 10$
99$:	return


; draw object's sprite
; R0 - object addr
ObjSprite:
	mov	#176640, R4
	mov	#176642, R5
	mov	C_OBJ_VADDR(R0), (R4)			; vaddr
	beq	99$					; not initialized?
	mov	C_OBJ_SADDR(R0), R1			; R1 - sprite addr
	add	#C_OBJ_SAVED, R0			; R0 - saved addr
	mov	(R4), (R0)+				; save vaddr
	mov	#C_SCRWID-2, R2
	mov	#C_TILE_DY, R3
10$:	mov	(R5), (R0)+				; save background
	bic	(R1)+, (R5)				; put mask
	bis	(R1)+, (R5)				; put pixels
	inc	(R4)
	mov	(R5), (R0)+				; save background
	bic	(R1)+, (R5)				; put mask
	bis	(R1)+, (R5)				; put pixels
	inc	(R4)
	mov	(R5), (R0)+				; save background
	bic	(R1)+, (R5)				; put mask
	bis	(R1)+, (R5)				; put pixels
	add	R2, (R4)
	sob	R3, 10$
99$:	return


; draws currently loaded level
DrawLevel:
	mov	#176640, R4
	mov	#176642, R5
	mov	#255., R3
10$:	call	Random8bit
	mov	R0, -(SP)
	call	50$
	mov	(SP)+, R0
	add	#256., R0
	call	50$
	sob	R3, 10$
	clr	R0
	call	50$
	mov	#256., R0	
50$:	; draw tile, R0 - level addr
	cmp	R0, #C_FIELD_DY*C_FIELD_DX
	bhis	90$	
	movb	LevelC(R0), R1				; tile #
	beq	90$					; empty tile
	asl	R0
	mov	Level2Vaddr(R0), (R4)			; set vaddr
	asl	R1
	mov	TilesAddr(R1), R0			; R0 tile addr
	; bis tile
	mov	#C_TILE_DY, R2
	mov	#C_SCRWID-2, R1
60$:	bis	(R0)+, (R5)
	inc	(R4)
	bis	(R0)+, (R5)
	inc	(R4)
	bis	(R0)+, (R5)
	add	R1, (R4)
	sob	R2, 60$
90$:	return


; draws instructions
ShowInstrA:
	clrb	bInstrShown
ShowInstr:
	tstb	bInstrShown
	bne	99$	
	comb	bInstrShown
	call	FadeScreen
	mov	#LevInstr, R0
	call	UnpackLevel
	call	DrawLevel
	mov	#MsgInstr00, R0
	mov	#8.*C_SCRWID+23.+C_VADDR+4, R5
	call	PrintStr
	mov	#MsgInstr01, R0
	mov	#82.*C_SCRWID+5.+C_VADDR+5, R5
	call	PrintStr
	mov	#MsgInstr02, R0
	mov	#118.*C_SCRWID+41.+C_VADDR+6, R5
	call	PrintStr
	mov	#MsgInstr03, R0
	mov	#154.*C_SCRWID+6.+C_VADDR+6, R5
	call	PrintStr
	mov	#MsgInstr04, R0
	mov	#190.*C_SCRWID+37.+C_VADDR+5, R5
	call	PrintStr
	mov	#MsgInstr05, R0
	mov	#216.*C_SCRWID+2.+C_VADDR+1, R5
	call	PrintStr
	mov	#MsgInstr06, R0
	mov	#226.*C_SCRWID+2.+C_VADDR+1, R5
	call	PrintStr
	mov	#MsgInstr07, R0
	mov	#236.*C_SCRWID+2.+C_VADDR+1, R5
	call	PrintStr
	clrb	bKeyCur
10$:	tstb	bKeyCur
	beq	10$
99$:	return

MsgInstr00:	.asciz	<2>"Instructions"
MsgInstr01:	.asciz	<1>"arrows to "<2>"move"
MsgInstr02:	.asciz	<2>"avoid"<1>" them"
MsgInstr03:	.asciz	<2>"collect"<1>" gold"
MsgInstr04:	.asciz	<2>"trap"<1>" with space"
MsgInstr05:	.asciz	<1>"Levels: "<2>"Sendik"
MsgInstr06:	.asciz	<1>"  Code: "<2>"Blaire"
MsgInstr07:	.asciz	<1>" Music: "<2>"Mic, Alos, Kenotron, Reddie"
		.even
MsgLevel:	.asciz	<1>"(***) LEVEL "<2>"A"<1>" (**) LIVES "<2>"0"<1>" (***)"
		.even

; draw level & lives
DrawBadge:
	clr	CurLives				; reset rotating lives
	; draw level and lives badge
	movb	bLevel, R0
	add	#'A, R0
	movb	R0, MsgLevel+14.
	mov	#MsgLevel, R0
	mov	#240.*C_SCRWID+C_VADDR+C_VDIFF, R5
	call	PrintStr
	return


; rotated lives drawing
DrawLives:
	; do not draw if not in a level mode
	cmpb	bGameMode, #C_MODE_LEVEL
	bne	99$
	; do not draw if they are equal already
	cmp	CurLives, Lives
	beq	99$
	; move up or down current digit
	blo	10$
	sub	#2, CurLives
	br	20$
10$:	add	#2, CurLives
20$:	mov	CurLives, R0
	asl	R0
	add	#FontData+512., R0
	mov	#176640, R4
	mov	#176642, R5
	mov	#240.*C_SCRWID+58.+C_VADDR, (R4)
	mov	#8., R3
	mov	#^B0000000011111111, R2
30$:	mov	(R0)+, R1
	bic	R2, R1
	mov	R1, (R5)
	inc	(R4)
	mov	(R0)+, R1
	bic	R2, R1
	mov	R1, (R5)
	add	#C_SCRWID-1, (R4)
	sob	R3, 30$
99$:	return


; draw tile from sprite data
; R0 - #, R1 - vaddr
; (!) save/restore R4, R5
DrawSTile:
	mov	R4, -(SP)
	mov	R5, -(SP)
	mov	#176640, R4
	mov	R1, (R4)
	mov	#176642, R5
	asl	R0
	mov	SpritesAddr(R0), R0
	mov	#C_SCRWID-2, R2
	mov	#C_TILE_DY, R3
10$:	tst	(R0)+
	mov	(R0)+, (R5)
	inc	(R4)
	tst	(R0)+
	mov	(R0)+, (R5)
	inc	(R4)
	tst	(R0)+
	mov	(R0)+, (R5)
	add	R2, (R4)
	sob	R3, 10$
	mov	(SP)+, R5
	mov	(SP)+, R4
	return


; darken vaddr by bic some pixels (used in non-selectable music menu)
; R1 - vaddr, R2 - width
; height is 8 lines
DarkenVaddr:
	mov	#176640, R4
	mov	#176642, R5
	mov	R1, (R4)
	mov	#C_SCRWID*2, R0
10$:	mov	#4, R3
20$:	bic	#^B1010101010101010, (R5)
	add	#C_SCRWID, (R4)
	bic	#^B0101010101010101, (R5)
	add	#C_SCRWID, (R4)
	sob	R3, 20$
	sub	#8.*C_SCRWID-1, (R4)
	sob	R2, 10$
	return


; //////////////////////////////////////////////////////////////////////////////
; // SOUND
; //////////////////////////////////////////////////////////////////////////////

bSoundFr5:	.word	0				; sound # to set on frame 5
bSoundNum:	.word	0				; sound # to start play

; play simple speaker sound
SoundProc:
	.ppu	#C_PPU_SND
	return


; check sound to set on frame 5
SoundSet5:
	cmpb	bFrame, #5.
	bne	99$
	movb	bSoundFr5, R0
	beq	99$
	movb	R0, bSoundNum
	clrb	bSoundFr5
99$:	return


; play simple tick
MenuSound:
	movb	#C_SND_MENU, bSoundNum
	br	SoundProc


; just clear sound vars
StopSound:
	clr	bSoundFr5
	clr	bSoundNum
	return


; //////////////////////////////////////////////////////////////////////////////
; // Utils
; //////////////////////////////////////////////////////////////////////////////

WaitVSync:
	clr	VsyCnt
10$:	tst	VsyCnt
	beq	10$
	return

; LFSR 8-bit random (Galois), 2^8-1 cycle
; cycle xor: 8-bit [10111000] 9-bit [110110000]
Random8bit:
	asr	#123
	bcc	30$
	mov	#^B0000000010111000, R0
	xor	R0, Random8bit+2
30$:	mov	Random8bit+2, R0
	return


; 4x5 numbers (aligned by 8 bytes)
;SprNumbers45:
;	.byte	^B00111111, ^B00110011, ^B00110011, ^B00110011, ^B00111111, 0, 0, 0
;	.byte	^B00001100, ^B00001100, ^B00001100, ^B00001100, ^B00001100, 0, 0, 0
;	.byte	^B00111111, ^B00110000, ^B00111111, ^B00000011, ^B00111111, 0, 0, 0
;	.byte	^B00111111, ^B00110000, ^B00111100, ^B00110000, ^B00111111, 0, 0, 0
;	.byte	^B00110011, ^B00110011, ^B00111111, ^B00110000, ^B00110000, 0, 0, 0
;	.byte	^B00111111, ^B00000011, ^B00111111, ^B00110000, ^B00111111, 0, 0, 0
;	.byte	^B00111111, ^B00000011, ^B00111111, ^B00110011, ^B00111111, 0, 0, 0
;	.byte	^B00111111, ^B00110000, ^B00110000, ^B00110000, ^B00110000, 0, 0, 0
;	.byte	^B00111111, ^B00110011, ^B00111111, ^B00110011, ^B00111111, 0, 0, 0
;	.byte	^B00111111, ^B00110011, ^B00111111, ^B00110000, ^B00111111, 0, 0, 0 

; print octal word (4x5 font), R0 - word, R5 - vaddr
;PrintOctal:
;	mov	#C_SCRWID, R2
;	mov	#6., R3
;	; 1st bit
;	clr	R1
;	br	22$
;20$:	; get number
;	clr	R1
;	asl	R0
;	rol	R1
;	asl	R0
;	rol	R1
;22$:	asl	R0
;	rol	R1	
;	; get spr addr
;	asl	R1
;	asl	R1
;	asl	R1
;	add	#SprNumbers45, R1
;	; put bits
;	movb	(R1)+, (R5)
;	add	R2, R5
;	movb	(R1)+, (R5)
;	add	R2, R5
;	movb	(R1)+, (R5)
;	add	R2, R5
;	movb	(R1)+, (R5)
;	add	R2, R5
;	movb	(R1)+, (R5)
;	sub	#C_SCRWID*4-1, R5
;	sob	R3, 20$
;	return	 


PriColorsTbl:
	.word	^B1111111111111111, ^B1111111100000000, ^B0000000011111111, ^B0000000000000000

; print string with 16x8 font
; R0 - string, R5 - vaddr
PrintStr:
	mov	#176640, R4
	mov	R5, (R4)
	mov	#176642, R5
	clr	R2					; R2 - font mask, default will be red
	clr	-(SP)					; temp word
10$:	movb	(R0)+, R1
	beq	99$
	cmp	R1, #3.					; is it 'color' symbol
	bhi	20$
	asl	R1
	mov	PriColorsTbl(R1), R2			; change font color mask
	br	10$
20$:	sub	#32., R1				; relative to 'space'
	ash	#5, R1					; *16 words
	add	#FontData, R1				; R1 = font data
	mov	#8., R3
30$:	mov	(R1)+, (SP)				; why don't just mov (R1)+, (R5) | bic R2, (R5) ?
	bic	R2, (SP)				; well.. better this way (slower though)
	mov	(SP), (R5)
	inc	(R4)
	mov	(R1)+, (SP)
	bic	R2, (SP)
	mov	(SP), (R5)
	bic	R2, (R5)
	add	#C_SCRWID-1, (R4)
	sob	R3, 30$
	sub	#8.*C_SCRWID-2, (R4)
	br	10$
99$:	tst	(SP)+
	return 


; ZX0 v2.2 standart unpacker
; original ZX0 encoder/decoder (c) Einar Saukas & Urusergi
; PDP11 version by reddie, 02-may-2024 (upd)
Unpack:	clr	R2
	movb	#200, R3
	sxt	R5
10$:	call	50$
	movb	(R0)+, (R1)+
	sob	R2, .-2
	aslb	R3
	bcs	30$
	call	50$
20$:	mov	R1, R4
	add	R5, R4
	movb	(R4)+, (R1)+
	sob	R2, .-2
	aslb	R3
	bcc	10$
30$:	mov	#-2, R2
	call	60$
	incb	R2
	bne	.+4
40$:	return
	swab	R2
	mov	R2, R5
	clrb	R5
	bisb	(R0)+, R5
	asr	R5
	mov	#1, R2
	bcs	.+6
	call	80$
	inc	R2
	br	20$
50$:	incb	R2
60$:	aslb	R3
	bne	70$
	movb	(R0)+, R3
	rolb	R3
70$:	bcs	40$
80$:	aslb	R3
	rol	R2
	br	60$

; put byte to (R1)+ in RAM12 (R1 - addr rel to 200000)
PutB12:	mov	R1, @#176640
	sec
	ror	@#176640
	mov	#176642, PutD12+4
	bcc	PutD12
	inc	PutD12+4
PutD12:	movb	#000, @#176642
	inc	R1
	return

; get byte (R4)+ from RAM12 -> put it to PutD12+2
GetB12:	mov	R4, @#176640
	sec
	ror	@#176640
	mov	#176642, GetD12+2
	bcc	GetD12
	inc	GetD12+2
GetD12:	movb	@#176642, PutD12+2
	inc	R4
	return

; ZX0 unpacker to RAM12
UnpR12:	clr	R2
	movb	#200, R3
	sxt	R5
10$:	call	50$
	;
11$:	movb	(R0)+, PutD12+2
	call	PutB12
	sob	R2, 11$
	;
	aslb	R3
	bcs	30$
	call	50$
20$:	mov	R1, R4
	add	R5, R4
	;
21$:	call	GetB12
	call	PutB12
	sob	R2, 21$
	;
	aslb	R3
	bcc	10$
30$:	mov	#-2, R2
	call	60$
	incb	R2
	bne	.+4
40$:	return
	swab	R2
	mov	R2, R5
	clrb	R5
	bisb	(R0)+, R5
	asr	R5
	mov	#1, R2
	bcs	.+6
	call	80$
	inc	R2
	br	20$
50$:	incb	R2
60$:	aslb	R3
	bne	70$
	movb	(R0)+, R3
	rolb	R3
70$:	bcs	40$
80$:	aslb	R3
	rol	R2
	br	60$

; //////////////////////////////////////////////////////////////////////////////
; // Data
; //////////////////////////////////////////////////////////////////////////////

VsyCnt:		.word	0

bKeyCur:	.word	0				; (!) words
bHaveAY:	.word	0				; (!) it's because they are set from PPU

bGameMode:	.byte	0
bInstrShown:	.byte	0
bLevel:		.byte	0
bGoldLeft:	.byte	0
bNextLevel:	.byte	0
bUseMusic:	.byte	0
		.even
Lives:		.word	0				; lives * 16.
CurLives:	.word	0				; currently shown lives on screen (*16.)

bFrame:		.byte	0
bFrame2:	.byte	0

DoorAddr:	.word	0				; addr of door on level
UpdTileAddr:	.word	UpdTIleTable			; addr+2 in table for update tiles
UpdTileTable:	.blkw	6				; max 6 tiles to update (isnt much?)

MsgOn:		.asciz	<2>"ON "
MsgOff:		.asciz	<1>"OFF"
MsgMenu001:	.asciz	<1>"1 "<1>"MUSIC"
MsgMenu002:	.asciz	<1>"2 "<1>"INSTRUCTIONS"
MsgMenu000:	.asciz	<3>"0 QUIT"
MsgSelLev:	.asciz	<1>"SELECT LEVEL <A>"
MsgSelLevA:	.asciz	<2>"A"
MsgPreSpace:	.asciz	<1>"PRESS "<2>"SPACE"
		.even

	; ////////////////////////////////////////////
	; RADIX 10 (!!!) RADIX 10 (!!!) RADIX 10 (!!!)
	; ////////////////////////////////////////////	
	.radix	10

; XY additions for moving (used bFrame/2)
DxLeft:		.byte	 0, -1,  0, -1,  0, -1
DxRight:	.byte	 0,  1,  0,  1,  0,  1
DyUp:		.byte	-2, -2, -2, -2, -2, -2
DyDown:		.byte	 2,  2,  2,  2,  2,  2
GDxLeft:	.byte	-1,  0, -1,  0, -1,  0

; sprite # for moving (they are x2 in length, used bFrame2/2)
SprLeft:	.byte	03, 04, 05, 04, 03, 04, 05, 04, 03, 04, 05, 04
SprRight:	.byte	00, 01, 02, 01, 00, 01, 02, 01, 00, 01, 02, 01
SprUpDown:	.byte	07, 06, 07, 08, 07, 06, 07, 08, 07, 06, 07, 08
SprOut:		.byte	16, 16, 17, 17, 18, 18 ; only 6 - for bFrame/2
SprSpawn:	.byte	18, 17, 17, 16, 16, 04
GSprRight:	.byte	10, 11, 12, 09, 10, 11, 12, 09, 10, 11, 12, 09
GSprUpDown:	.byte	11, 11, 09, 09, 11, 11, 09, 09, 11, 11, 09, 09
GSprWait:	.byte	13, 13, 14, 14, 15, 15 ; only 6 - for bFrame/2
GSprOut:	.byte	15, 15, 14, 14, 13, 13

; bit masks in table below
C_BIT_MOVE	= 1	; moveable tile, can be walked upon
C_BIT_FALL	= 2	; fallable tile, can fall through
C_BIT_DEST	= 4	; tile can be destroyed with space
TTileBits:	.byte	1+2+0, 0+0+4, 0+0+0, 0+0+0, 0+0+0, 1+0+0, 1+2+0, 1+0+0, 1+2+0, 1+2+0
		.byte	0+0+0, 0+0+0, 0+0+0, 0+0+0, 0+0+0, 0+0+0, 0+0+0, 0+0+0, 0+0+0, 1+2+0 ; <- remo tile
		.byte	1+2+0, 1+2+0, 1+2+0, 1+2+0, 1+2+0, 1+2+0, 1+2+0, 1+2+0, 1+2+0, 1+2+0

; states to level addr moving (stop, left, right, up, down, fall, wait, out)
DStateLevaddr:	.byte	0, -1, 1, -C_FIELD_DX, C_FIELD_DX, C_FIELD_DX, 0, 0

; proposed states for keys and check avail
KeysActions:	.word	C_KEY_ENTER,  C_KEY_LEFT,   C_KEY_RIGHT,   C_KEY_UP,   C_KEY_DOWN,   C_KEY_DOWN,   -1,           -1
TStateAvail:	.word	ChkSStop,     ChkSLeft,     ChkSRight,     ChkSUp,     ChkSDown,     ChkSFall,     ChkSSetC,     ChkSSetC

; shadow tiles for state
TShadowTiles:	.byte	0, 21, 27, 0, 0, 0, 0, 0

; differences in coords 
GhostDiff:	.word	0, 0, 0, 0, 0, 0, 0, 0
; opposite state in moving dir
TStateOppo:	.byte	C_STATE_STOP, C_STATE_RIGHT, C_STATE_LEFT, C_STATE_DOWN, C_STATE_UP, C_STATE_FALL, C_STATE_WAIT, C_STATE_OUT


; first is player, then ghosts, X=0 - no object
Object:		.word	0				; 000 X
		.word	0				; 002 Y
		.word	0				; 004 vaddr
		.word	0				; 006 sprite #
		.word	0				; 010 sprite addr
		.word	0				; 012 saved background vaddr
		.blkw	C_TILE_SIZE			; 014 saved background data
		.word	0				; addr in level
		.word	0				; state
		.word	0				; init value of X
		.word	0				; init value of Y
		.word	0				; init value of level addr
		.word	0				; ladders count around
ObjectEnd:	.blkb	ObjectEnd-Object*2		; 2 ghost objects
ObjectsEnd:	

; removed (with space) tiles, [level addr], [timer to restore]
Removed:	.blkw	C_MAX_REMO*3
RemovedEnd:	

; currently loaded level
LevelC:		.blkb	C_FIELD_DY*C_FIELD_DX
LevelCEnd:


; level for instructions
LevInstr:
@packstart10
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0, 24,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0, 29, 22, 23,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  1,  1,  2,  3,  3,  3,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 22, 22, 25,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 28,  0, 26, 27, 29,  0,  0
	.byte	 0,  0,  0,  5,  6,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  3,  3,  4,  1,  0
	.byte	 0,  0,  0,  5,  2,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0, 29,  5,  6,  6,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  1,  2,  3,  3,  3,  3,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 26, 27, 29,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1, 28,  1,  1,  1,  1,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  3,  3,  3,  3,  3,  4,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
@packend

; level for game over
LevOver:
@packstart10
	.byte	19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19
	.byte	19,  2,  4, 19, 19, 19,  2,  4, 19, 19, 18, 19, 19, 19, 18, 19,  2,  3,  3,  4
	.byte	18, 19, 19, 18, 19, 18, 19, 19, 18, 19,  2,  4, 19,  2,  4, 19, 18, 19, 19, 19
	.byte	18, 19, 19, 19, 19, 18, 19, 19, 18, 19, 18, 19, 18, 19, 18, 19,  2,  3,  4, 19
	.byte	18, 19,  2,  4, 19,  2,  3,  3,  4, 19, 18, 19, 19, 19, 18, 19, 18, 19, 19, 19
	.byte	18, 19, 19, 18, 19, 18, 19, 19, 18, 19, 18, 19, 19, 19, 18, 19, 18, 19, 19, 19
	.byte	19,  2,  4, 19, 19, 18, 19, 19, 18, 19, 18, 19, 19, 19, 18, 19,  2,  3,  3,  4
	.byte	19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19
	.byte	19,  2,  4, 19, 19, 18, 19, 19, 19, 18, 19,  2,  3,  3,  4, 19,  2,  3,  4, 19
	.byte	18, 19, 19, 18, 19, 18, 19, 19, 19, 18, 19, 18, 19, 19, 19, 19, 18, 19, 19, 18
	.byte	18, 19, 19, 18, 19, 18, 19, 19, 19, 18, 19,  2,  3,  4, 19, 19, 18, 19, 19, 18
	.byte	18, 19, 19, 18, 19, 18, 19, 19, 19, 18, 19, 18, 19, 19, 19, 19,  2,  3,  4, 19
	.byte	18, 19, 19, 18, 19, 19, 18, 19, 18, 19, 19, 18, 19, 19, 19, 19, 18, 19, 19, 18
	.byte	19,  2,  4, 19, 19, 19, 19, 18, 19, 19, 19,  2,  3,  3,  4, 19, 18, 19, 19, 18
	.byte	19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0, 28, 28, 28, 28, 28,  0,  0,  6, 29,  0,  0, 28, 28, 28, 28, 28,  0,  0
	.byte	 0,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  4,  0
@packend

; level for win game
LevWin:
@packstart10
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 30, 31, 32,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 33, 34, 35,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 36, 37, 38,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0, 29, 39, 40, 41,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  2,  3,  3,  3,  3,  3,  4,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  2,  3,  3,  3,  3,  3,  4,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  2,  3,  3,  3,  3,  3,  4,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  2,  3,  3,  3,  4,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  2,  3,  3,  3,  4,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  2,  3,  3,  3,  4,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  2,  3,  3,  3,  4,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  2,  3,  3,  3,  4,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  2,  3,  3,  3,  4,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  2,  3,  3,  3,  4,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0, 18, 19,  5, 19, 18,  0,  0,  0,  0,  0,  0,  0,  0
@packend
	.even


; table of packed level addrs
LevelTable:	.word	LevA, LevB, LevC, LevD
		.word	LevE, LevF, LevG, LevH
		.word	LevI, LevJ, LevK, LevL

	; 1-dirt, 2,3,4-stone, 5-ladder, 6-box, 7-chain, 8-door, 9-exit
LevA:
@packstart10
;	.byte	28,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1, 28
;	.byte	 1,  1,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  5,  0,  0,  1,  0
;	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  5,  0,  0,  0,  0
;	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
;	.byte	 0,  0,  0,  0,  0,  0,  6,  0, 29,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
;	.byte	 0,  2,  3,  4,  5,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  5,  3,  3,  4,  0
;	.byte	 0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
;	.byte	 0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
;	.byte	 0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
;	.byte	 0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
;	.byte	 0,  0,  0,  0,  5,  0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  5,  0,  0,  0,  0
;	.byte	 0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
;	.byte	 0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
;	.byte	 0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
;	.byte	 0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
;	.byte	 0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
;	.byte	 0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
;	.byte	 0,  1,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  1,  0

	.byte	28,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  5,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0
	.byte	 1,  1,  5,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  5,  1,  1,  1,  5,  1
	.byte	 0,  1,  5,  0,  0,  0,  5,  1,  1,  0,  0,  0,  1,  1,  5,  0,  0,  0,  5,  6
	.byte	 6,  1,  5,  0,  0,  0,  5,  1,  1,  6,  6,  6,  1,  1,  5,  0,  0,  0,  5,  0
	.byte	 1,  1,  5,  0,  0,  0,  5,  1,  1,  1,  1,  1,  1,  1,  5,  1,  1,  1,  5,  1
	.byte	 0,  0,  5,  0,  0,  6,  5,  0,  0,  5,  0,  0,  0,  0,  5,  6,  0,  6,  5,  0
	.byte	 0,  0,  5,  0,  0,  0,  5,  0,  0,  5,  0,  0,  0,  0,  5,  0,  6,  0,  5,  0
	.byte	 0,  0,  5,  0,  0,  0,  5,  0,  0,  5,  0,  6,  0,  0,  5,  6,  0,  6,  5,  0
	.byte	 5,  1,  1,  7,  7,  7,  5,  2,  4,  5,  2,  3,  3,  4,  5,  0,  0,  0,  5,  0
	.byte	 5,  0,  0,  0,  0,  0,  5,  0,  0,  5,  0, 29,  0,  0,  5,  7,  7,  7,  5,  0
	.byte	 5,  0,  0,  0,  0,  0,  5,  0,  0,  5,  0,  0,  0,  0,  5,  0,  0,  0,  5,  0
	.byte	 2,  4,  5,  0,  0,  0,  5,  0,  0,  5,  0,  0,  0,  0,  5,  0,  0,  0,  5,  0
	.byte	 0,  0,  5,  0,  0,  0,  5,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  4,  5,  0
	.byte	 0,  0,  5,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0
	.byte	 0,  0,  5,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0
	.byte	 0,  0,  5,  0,  0,  0,  5,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  5,  0
	.byte	 6,  6,  5,  2,  3,  3,  3,  4,  6,  6,  0,  0,  0,  0,  0,  0,  0,  0,  5,  1
@packend

LevB:
@packstart10
	.byte	 8,  0,  0,  0,  0, 28,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  5,  0,  0,  0,  0,  6,  0,  6,  0,  6,  0,  0,  0,  5,  1,  0,  0,  0,  0
	.byte	 0,  5,  0,  5,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  5,  0,  0,  0,  0,  0
	.byte	 7,  7,  7,  5,  0,  1,  1,  6,  6,  6,  0,  0,  0,  0,  5,  0,  6,  0,  5,  1
	.byte	 0,  0,  0,  5,  0,  1,  1,  7,  7,  7,  7,  7,  7,  0,  5,  0, 18,  0,  5,  0
	.byte	 0,  0,  0,  5,  0,  0,  0,  0, 29,  0,  0,  0,  0,  0,  5,  0,  0,  0,  5,  0
	.byte	 0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  5,  6
	.byte	 2,  3,  3,  3,  3,  4,  5,  0,  0,  5,  7,  7,  5,  7,  5,  0,  0,  0,  5,  0
	.byte	 0,  0,  0,  6,  0,  6,  5,  0,  0,  5,  0,  0,  5,  0,  1,  1,  1,  1,  5,  1
	.byte	 0,  7,  7,  7,  7,  7,  5,  0,  0,  5,  0,  0,  5,  0,  0,  6,  0,  0,  5,  0
	.byte	 5,  0,  0,  0,  0,  0,  5,  7,  7,  7,  7,  7,  5,  7,  7,  0,  0,  0,  5,  0
	.byte	 5,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  5,  0,  0,  0,  6,  0,  5,  0
	.byte	 5,  0,  0,  0,  0,  0,  5,  4,  0,  6,  0,  0,  5,  0,  0,  0,  1,  0,  5,  6
	.byte	 5,  7,  7,  2,  3,  3,  3,  4,  0,  0,  0,  0,  5,  1,  0,  0,  0,  0,  5,  0
	.byte	 5,  0,  0,  0,  0,  0,  2,  3,  3,  3,  4,  5,  5,  7,  7,  7,  5,  0,  5,  0
	.byte	 5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  5,  0,  0,  0,  5,  0,  5,  0
	.byte	 5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  5,  0,  0,  0,  5,  0,  5,  0
	.byte	 1,  1,  1,  1,  1,  1,  5,  0,  0,  0,  0,  5,  2,  3,  3,  3,  3,  3,  3,  4
@packend

LevC:
@packstart10
	.byte	 0,  0,  0,  0, 29,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,  6,  0,  0,  8,  5
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  5,  2,  3,  3,  3,  3,  3,  3,  4,  0,  0,  5
	.byte	 5,  7,  7,  7,  7,  7,  7,  7,  5,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  5
	.byte	 5,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5
	.byte	 5,  0,  0,  6,  0,  6,  0,  0,  5,  1,  1,  1,  1,  1,  5,  1,  1,  1,  1,  5
	.byte	 5,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0, 28,  0,  0,  5,  0,  0,  0,  0,  5
	.byte	 5,  5,  1,  1,  1,  1,  1,  1,  1,  5,  0,  6,  6,  0,  5,  0,  6,  0,  0,  5
	.byte	 5,  5,  0,  1,  6,  1,  6,  1,  0,  5,  0,  0,  0,  0,  5,  0,  0,  0,  0,  5
	.byte	 0,  5,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  5,  0,  0,  0,  0,  5
	.byte	 0,  5,  0,  0,  0,  6,  0,  6,  0,  5,  1,  1,  1,  1,  1,  1,  1,  0,  0,  5
	.byte	 0,  5,  5,  7,  7,  7,  0,  0,  0,  5,  0,  6,  0,  6,  0,  6,  0,  0,  0,  5
	.byte	 0,  5,  5,  0,  0,  0,  0,  0,  0,  5,  0,  2,  3,  3,  3,  4,  0,  6,  0,  5
	.byte	 0,  0,  5,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  5,  0,  0,  0,  0,  5
	.byte	 7,  7,  5,  7,  7,  7,  7,  7,  7,  5,  0,  0,  0,  0,  5,  7,  7,  7,  7,  5
	.byte	 0,  0,  5,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  5,  0,  0,  0,  0,  5
	.byte	 0,  0,  5,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  5,  0,  0,  0,  0,  5
	.byte	 0,  0,  5,  1,  1,  1,  1,  1,  1,  1,  1,  1,  5,  7,  7,  7,  7,  7,  7,  5
	.byte	 0,  0,  5,  0,  0,  0,  0,  0, 28,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  5
@packend

LevD:
@packstart10
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  0, 29,  0,  0,  0,  0,  0,  0
	.byte	 0,  6,  0,  0,  0,  2,  3,  3,  3,  3,  4,  5,  6,  0,  0,  0,  0,  0,  0,  5
	.byte	 7,  7,  7,  7,  5,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  5
	.byte	 0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0, 28,  0,  0,  5
	.byte	 0,  0,  0,  0,  5,  0,  0,  0,  0,  5,  2,  3,  3,  3,  4,  7,  7,  7,  7,  7
	.byte	 1,  1,  1,  1,  1,  1,  1,  1,  1,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  2,  3,  3,  3,  1,  3,  3,  3,  4
	.byte	 0,  0,  0,  0,  6,  0,  0,  0,  0,  5,  0,  2,  4,  6,  6,  6,  2,  3,  4,  0
	.byte	 2,  4,  5,  0,  0,  0,  5,  1,  1,  1,  2,  4,  0,  0,  2,  3,  3,  3,  4,  0
	.byte	 0,  0,  5,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  5,  1,  1,  1,  5,  0,  6,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  5,  0,  0,  0,  5,  0,  0,  0,  0,  5,  2,  4,  1,  1,  2,  3,  4,  0
	.byte	 2,  4,  5,  0,  0,  0,  5,  1,  1,  1,  1,  5,  0,  1,  1,  1,  1,  0,  0,  0
	.byte	 0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  1,  0,  0,  1,  0,  0,  0
	.byte	 0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  1,  6,  6,  1,  0,  0,  0
	.byte	 0,  0,  5,  2,  3,  3,  3,  3,  3,  3,  3,  4,  0,  1,  1,  1,  1,  0,  0,  0
	.byte	 0,  0,  5,  0,  0,  0,  0,  0, 28,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
@packend

LevE:
@packstart10
	.byte	 0,  6,  0,  6,  0,  6,  0,  6,  0,  0,  0,  0, 29,  0,  0,  0,  0,  5,  8, 28
	.byte	 2,  3,  3,  3,  3,  3,  3,  3,  3,  4,  5,  0,  0,  0,  0,  0,  0,  5,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  6,  6,  5,  0,  0,  7,  7,  7,  7,  5,  0,  0
	.byte	 0,  5,  1,  1,  1,  1,  1, 18,  0,  0,  5,  0,  0,  0,  0,  0,  0,  5,  0,  6
	.byte	 0,  5,  0,  0,  0,  0,  0, 18,  7,  7,  7,  7,  7,  7,  0,  5,  2,  3,  3,  4
	.byte	 0,  5,  0,  0,  0,  0,  0, 18,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
	.byte	 0,  5,  0,  0,  0,  0,  0,  2,  3,  3,  3,  3,  3,  4,  0,  5,  0,  0,  0,  0
	.byte	 7,  7,  7,  7,  7,  7,  5, 18,  6,  0,  0,  0,  0, 18,  0,  2,  3,  3,  4,  5
	.byte	 0,  0,  0,  0,  0,  0,  5, 18,  5,  0,  0,  0,  0, 18,  0,  0,  0,  0,  0,  5
	.byte	 0,  0,  0,  0,  0,  0,  5, 18,  5,  7,  7,  7,  6, 18,  0,  0,  0,  0,  0,  5
	.byte	 0,  1,  1,  0,  0,  0,  5, 18,  5,  0,  6,  0,  0, 18,  6,  0,  0,  0,  0,  5
	.byte	 1,  6,  6,  1,  1,  0,  5, 18,  5,  0,  0,  7,  7, 18,  0,  0,  0,  5,  2,  4
	.byte	 1,  7,  7,  1,  1,  7,  5,  2,  3,  4,  5,  0,  0,  5,  7,  7,  7,  5,  0,  0
	.byte	 1,  1,  1,  1,  1,  0,  5,  0,  0,  0,  5,  7,  7,  5,  0,  0,  0,  5,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  5,  0,  0,  5,  0,  0,  0,  5,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  5,  0,  0,  5,  1,  1,  1,  1,  1,  0
	.byte	 0,  5,  7,  7,  7,  7,  5,  0,  0,  0,  5,  0,  0,  5,  0,  0,  0,  0,  0,  6
	.byte	 1,  5,  0,  0,  0,  0,  5,  2,  3,  3,  3,  3,  3,  3,  3,  4,  5,  0,  0,  0
@packend

LevF:
@packstart10
	.byte	 5,  8,  0,  0,  0,  0,  0,  0,  0,  0, 29,  0,  0,  0,  0,  0,  0,  0,  0,  5
	.byte	 5,  0,  0,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  5
	.byte	 7,  7,  7,  1,  7,  7,  7,  7,  5,  0,  6,  0,  5,  7,  7,  7,  1,  7,  7,  7
	.byte	 0,  6,  1,  1,  1,  6,  0,  0,  5,  6, 18,  6,  5,  0,  6,  1,  1,  1,  6,  0
	.byte	 0,  2,  4,  6,  2,  4,  0,  0,  5,  2,  3,  4,  5,  0,  2,  4,  6,  2,  4,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0
	.byte	 5,  7,  1,  6,  1,  1,  6,  1,  5,  1,  6,  1,  5,  1,  6,  1,  1,  6,  7,  5
	.byte	 5,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  5
	.byte	 5,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  5
	.byte	 5,  7,  7,  7,  7,  7,  7,  7,  5,  7,  7,  7,  5,  7,  7,  7,  7,  7,  7,  5
	.byte	 5,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  5
	.byte	 5,  0,  0,  0,  6,  6,  0,  0,  5,  6,  0,  6,  5,  0,  0,  6,  6,  0,  0,  5
	.byte	 5,  7,  7,  5,  0,  0,  5,  7,  5,  7, 18,  7,  5,  7,  5,  0,  0,  5,  7,  5
	.byte	 5,  0,  0,  5,  0,  0,  5,  0,  5,  2,  3,  4,  5,  0,  5,  0,  0,  5,  0,  5
	.byte	 5,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  4,  1,  1,  1,  1,  1,  1,  1,  5
	.byte	 5,  6,  1,  0,  5,  0,  0,  6,  1,  2,  3,  4,  1,  6,  0,  5,  0,  1,  6,  5
	.byte	 5, 28,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0, 28,  5
@packend

LevG:
@packstart10
	.byte	 5,  8,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 5,  0,  0, 29,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  6,  0,  6,  0,  0,  0
	.byte	 5,  0,  0,  0,  0,  0,  0,  7,  7,  5,  1,  1,  1,  1,  1,  1,  1,  1,  7,  5
	.byte	 5,  7,  7,  7,  7,  5,  0,  6,  0,  5,  0,  0,  0,  6,  0,  6, 28,  0,  0,  5
	.byte	 5,  0,  0,  0,  0,  1,  1,  0,  0,  5,  0,  7,  7,  7,  7,  7,  7,  7,  0,  5
	.byte	 5,  0,  0,  0,  0,  0, 28,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5
	.byte	 5,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5
	.byte	 5,  0,  1,  1,  1,  1,  1,  1,  1,  5,  7,  7,  7,  5,  7,  7,  7,  7,  6,  5
	.byte	 5,  6,  0,  6,  1,  6,  6,  0,  0,  5,  0,  1,  0,  5,  0,  1,  0,  1,  0,  5
	.byte	 5,  0,  0,  1,  1,  1,  1,  1,  0,  5,  0,  1,  6,  5,  6,  1,  0,  1,  6,  5
	.byte	 1,  1,  1,  1,  6,  6,  0,  1,  0,  5,  0,  1,  0,  5,  0,  1,  0,  1,  1,  1
	.byte	 0,  0,  5,  1,  1,  1,  5,  1,  0,  5,  0,  1,  1,  1,  1,  1,  0,  0,  0,  0
	.byte	 0,  0,  5,  0,  0,  0,  5,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0
	.byte	 0,  0,  5,  0,  0,  0,  5,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  5,  7,  7,  7,  7,  7,  7,  5,  7,  7,  7,  7,  7,  7,  5,  0,  0,  0
	.byte	 7,  7,  5,  0,  0,  0,  0,  6,  0,  5,  0,  6,  0,  0,  0,  0,  5,  7,  7,  7
	.byte	 0,  0,  5,  0,  0,  5,  7,  7,  7,  5,  7,  7,  7,  5,  0,  0,  5,  0,  0,  0
	.byte	 0,  0,  5,  0,  0,  5,  0,  0,  0,  5,  0,  0,  0,  5,  0,  0,  5,  0,  0,  0
@packend

LevH:
@packstart10
	.byte	 5,  8,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,  0,  0,  0
	.byte	 5,  0,  0,  0,  0,  6,  0,  0,  0,  0,  5,  1,  1,  1,  5,  0,  5,  1,  5,  6
	.byte	 5,  0,  0,  0,  0,  2,  3,  3,  3,  3,  3,  3,  3,  4,  5,  0,  5,  2,  3,  4
	.byte	 1,  1,  1,  5,  0,  0,  0,  0,  0,  6,  0,  6,  0,  0,  5,  0,  5,  0,  0,  0
	.byte	 0,  6,  0,  5,  0,  0,  5,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  4,  5
	.byte	 0,  0,  0,  5,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5
	.byte	 0,  0,  0,  5,  0,  0,  5,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,  0,  5
	.byte	 7,  7,  7,  7,  7,  7,  5,  7,  2,  3,  3,  3,  4,  0,  0,  6,  0,  0,  0,  5
	.byte	 0, 28,  6,  0,  6,  0,  5,  0, 18,  6,  5,  6, 18,  0,  5,  7,  5,  7,  7,  5
	.byte	 0,  5,  0,  0,  0,  0,  5,  0, 18,  0,  5,  0, 18,  0,  5,  0,  5,  0,  0,  5
	.byte	 0,  5,  0,  0,  0,  0,  5,  0, 18, 28,  5,  0,  0,  0,  5,  7,  5,  1,  1,  1
	.byte	 0,  5,  2,  4,  5, 18,  5,  0,  2,  1,  3,  3,  3,  4,  5,  0,  5,  1,  0,  0
	.byte	 0,  5, 18,  0,  5, 18,  5,  0,  0,  0, 29,  0,  0,  0,  5,  1,  1,  1,  0,  0
	.byte	 0,  6, 18,  6,  5, 18,  5,  0,  0,  0,  0,  0,  0,  0,  5,  1,  0,  0,  6,  6
	.byte	 0,  0, 18,  0,  5, 18,  5,  0,  0,  0,  0,  0,  0,  0,  5,  1,  0,  0,  0,  0
	.byte	 0,  0,  2,  3,  3,  4,  1,  1,  1,  1,  5,  1,  1,  1,  1,  1,  0,  2,  3,  4
	.byte	 6,  6,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  6
	.byte	 2,  3,  4,  5,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  5,  2,  4
@packend

LevI:
@packstart10
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  8,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0
	.byte	 5,  1,  1,  1,  5,  1,  1,  1,  1,  0,  5,  1,  1,  1,  1,  5,  0,  0,  0,  0
	.byte	 5,  0,  0,  0,  5,  0,  1,  0,  0,  0,  5,  0,  6,  0,  0,  5,  0,  0,  0,  0
	.byte	 5,  0,  0,  0,  5,  0,  6,  0,  6,  0,  5,  0,  0,  0,  5,  2,  3,  3,  4,  0
	.byte	 1,  1,  5,  1,  5,  0,  1,  0,  0,  0,  5,  0,  0, 28,  5,  0,  0,  0,  0,  0
	.byte	 0,  0,  5,  0,  5,  0,  1,  7,  7,  7,  7,  7,  0,  0,  5,  0,  0,  0,  0,  0
	.byte	 0,  0,  5,  0,  5,  0,  1,  0,  0,  5,  1,  1,  1,  1,  1,  1,  1,  5,  0,  0
	.byte	 6,  0,  5,  0,  5,  0,  0,  0,  0,  5,  0,  0,  0, 29,  0,  0,  0,  5,  0,  6
	.byte	 0,  0,  5,  2,  3,  3,  4,  0,  0,  5,  0,  0,  6,  0,  6,  6,  0,  5,  0,  0
	.byte	 0,  0,  5,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0
	.byte	 0,  0,  5,  0,  0,  0,  0,  0,  5,  2,  4,  5,  0,  0,  0,  0,  0,  5,  0,  0
	.byte	 0,  0,  5,  1,  1,  1,  1,  1,  5,  0,  0,  5,  1,  1,  1,  1,  1,  5,  1,  1
	.byte	 7,  7,  5,  1,  6,  0,  5,  0,  5,  0,  0,  5,  0,  0,  0,  6,  0,  5,  0,  0
	.byte	 0,  0,  5,  1,  1,  1,  5,  1,  1,  1,  1,  1,  1,  5,  0,  0,  0,  5,  0,  6
	.byte	 0,  0,  5,  0,  0,  0,  5,  0,  6,  0, 28,  6,  0,  5,  0,  0,  0,  5,  0,  0
	.byte	 6,  0,  5,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  5,  0,  0
	.byte	 3,  3,  3,  3,  3,  4,  5,  0,  0,  0,  0,  0,  0,  5,  2,  3,  3,  3,  3,  4
@packend

LevJ:
@packstart10
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 29,  0,  0,  0,  0,  0,  0,  0,  0,  5
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5
	.byte	 0,  0,  0,  0,  0,  0, 28,  0,  0,  1,  1,  1,  7,  7,  7,  7,  7,  7,  7,  5
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0, 28,  0,  0,  0,  5
	.byte	 0,  0,  0,  0,  0,  0,  5,  7,  5,  7,  5,  7,  5,  7,  5,  7,  5,  0,  0,  5
	.byte	 0,  0,  0,  0,  0,  0,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  0,  0,  5
	.byte	 0,  0,  0,  0,  0,  0,  5,  7,  5,  7,  5,  7,  5,  7,  5,  7,  5,  0,  0,  5
	.byte	 0,  0,  0,  0,  0,  0,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  0,  0,  5
	.byte	 0,  8,  0,  0,  0,  0,  5,  7,  5,  7,  5,  7,  5,  7,  5,  7,  5,  0,  0,  5
	.byte	 0,  5,  0,  0,  0,  0,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  0,  0,  5
	.byte	 0,  5,  0,  0,  0,  0,  5,  7,  5,  7,  5,  7,  5,  7,  5,  7,  5,  0,  0,  5
	.byte	 5,  1,  1,  1,  0,  0,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  0,  0,  5
	.byte	 5,  1,  6,  6,  1,  0,  7,  7,  7,  7,  5,  7,  7,  7,  7,  7,  7,  0,  1,  5
	.byte	 5,  1,  1,  1,  1,  1,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  1,  1,  5
	.byte	 5,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  5
	.byte	 5,  0,  1,  6,  6,  6,  6,  6,  1,  6,  6,  1,  6,  6,  1,  6,  6,  1,  0,  5
	.byte	 5,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  5
	.byte	 5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5
@packend

LevK:
@packstart10
	.byte	 0,  0,  0,  0,  0, 28,  0,  0,  0,  0,  0,  0,  0, 28,  0,  0,  0,  0,  0,  0
	.byte	 0,  8,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  2,  3,  3,  3,  3,  3,  3,  4,  5,  2,  3,  3,  3,  3,  3,  3,  4,  7,  5
	.byte	 0, 18,  0,  0,  6,  0,  6,  0,  6,  5,  6,  0,  6,  0,  6,  0,  0, 18,  0,  5
	.byte	 0, 18,  5,  7,  7,  7,  7,  7,  7,  5,  7,  7,  7,  7,  7,  7,  5, 18,  0,  5
	.byte	 0,  0,  5,  2,  3,  4,  0,  0,  0,  5,  0,  0,  0,  2,  3,  4,  5,  0,  0,  5
	.byte	 0,  0,  5,  0,  0, 18,  5,  2,  4,  5,  2,  4,  5, 18,  0,  0,  5,  0,  0,  5
	.byte	 0,  0,  5,  0,  0,  0,  5,  0,  0,  5,  0,  0,  5,  0,  0,  0,  5,  0,  0,  5
	.byte	 5,  1,  1,  1,  1, 18,  5,  0,  0,  5,  0,  0,  5, 18,  1,  1,  1,  1,  7,  5
	.byte	 5,  0,  1,  6,  6, 18,  5,  7,  7,  5,  7,  7,  5, 18,  6,  6,  1,  0,  0,  5
	.byte	 5,  0,  0,  1,  1, 18,  5,  0,  6,  5,  6,  0,  5, 18,  1,  1,  0,  0,  0,  5
	.byte	 5,  0,  0,  0,  1, 18,  5,  0,  0,  5,  0,  0,  5, 18,  1,  0,  0,  0,  0,  5
	.byte	 5,  0,  0,  0,  5, 18,  1,  1,  1,  1,  1,  1,  1, 18,  5,  0,  0,  5,  1,  1
	.byte	 5,  0,  0,  0,  5, 18,  1,  1,  1,  1,  1,  1,  1, 18,  5,  0,  0,  5,  1,  1
	.byte	 5,  0,  0,  0,  5, 18,  1,  1,  6,  0,  6,  1,  1, 18,  5,  7,  7,  5,  1,  1
	.byte	 1,  1,  1,  1,  5, 18,  1,  6,  1, 29,  1,  6,  1, 18,  5,  0,  0,  5,  1,  6
	.byte	 6,  0,  0,  0,  5, 18,  1,  1,  1,  1,  1,  1,  1, 18,  5,  0,  0,  5,  1,  1
	.byte	 2,  3,  3,  4,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  2,  3,  3,  3,  4
@packend

LevL:
@packstart10
	.byte	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  0,  0,  0,  0,  0,  0,  0,  0,  0
	.byte	 0,  0,  0,  0,  0,  0, 28,  0,  0,  0,  5,  0,  0,  0, 28,  0,  0,  0,  0,  0
	.byte	 5, 18,  5,  7,  7,  7,  7,  7,  7,  7, 18,  7,  7,  7,  7,  7,  7,  5,  7,  5
	.byte	 5,  0,  5,  0,  0,  6, 18,  6,  5,  2,  3,  4,  5,  6, 18,  6,  0,  5,  0,  5
	.byte	 5,  6,  7,  7,  5,  2,  3,  4,  5,  2,  3,  4,  5,  2,  3,  4,  0,  5,  0,  5
	.byte	 5,  0,  0,  0,  5,  2,  3,  4,  5,  2,  3,  4,  5,  2,  3,  4,  6,  5,  6,  5
	.byte	 5,  7,  7,  5,  7,  0,  0,  0,  5,  0,  0,  0,  5,  0,  0,  0,  0,  5,  0,  5
	.byte	 5,  6,  6,  5,  0,  2,  3,  3,  4,  5,  6,  5,  2,  3,  3,  4,  7,  7,  7,  5
	.byte	 5,  0,  0,  5,  0,  0,  2,  3,  4,  5,  6,  5,  2,  3,  4,  0,  0,  6,  0,  5
	.byte	 5,  0,  0,  5,  0,  0,  0,  2,  4,  5,  6,  5,  2,  4,  0,  0,  0,  0,  0,  5
	.byte	 5,  0,  0,  5,  0,  0,  0,  2,  4,  1,  1,  1,  2,  4,  0,  0, 29,  0,  0,  5
	.byte	 5,  7,  7,  7,  7,  7,  5,  0,  2,  3,  3,  3,  4,  0,  0,  0,  0,  0,  0,  5
	.byte	 5,  0,  0,  0,  0,  0,  5,  6,  0,  2,  3,  4,  0,  5,  7,  7,  7,  7,  7,  5
	.byte	 5,  0,  0,  5,  7,  7,  7,  0,  0,  2,  3,  4,  0,  5,  6,  5,  7,  7,  7,  5
	.byte	 5,  0,  0,  5,  0,  0,  6,  0,  0,  0,  0,  0,  0,  5,  0,  5,  0,  6,  0,  5
	.byte	 5,  0,  0,  5,  7,  7,  7,  7,  7,  7,  7,  7,  7,  5,  0,  5,  0,  0,  0,  5
	.byte	 2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  4
	.byte	 2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  4
@packend

	.even

	; //////////////////////////////////////////////////////////////////////
	; // RADIX 8 (!!!)
	; //////////////////////////////////////////////////////////////////////
	.radix	8

@include inc_graphics.mac
	.even

@include music.mac
	.even

@include appu.mac
	.even

Level2Vaddr = PpuStart

	.if LT C_MAX_RAM-.
	.error maximum ram exceeded
	.endc
End:
	.end	Start
